"""
Sistema de mem√≥ria contextual com estrat√©gia LRU para o agente AURALIS
Mant√©m contexto da conversa com gerenciamento eficiente de mem√≥ria
"""

import time
import json
from collections import OrderedDict
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
import threading

class MemoriaContextualLRU:
    """
    Sistema de mem√≥ria contextual usando Least Recently Used (LRU)
    para manter hist√≥rico de conversas com limite de capacidade
    """
    
    def __init__(self, capacidade_maxima: int = 100, tempo_expiracao_minutos: int = 30):
        """
        Inicializa o sistema de mem√≥ria
        
        Args:
            capacidade_maxima: N√∫mero m√°ximo de entradas na mem√≥ria
            tempo_expiracao_minutos: Tempo em minutos para expirar entradas antigas
        """
        self.capacidade_maxima = capacidade_maxima
        self.tempo_expiracao = timedelta(minutes=tempo_expiracao_minutos)
        
        # OrderedDict mant√©m ordem de inser√ß√£o e permite reordenar
        self.memoria: OrderedDict[str, Dict[str, Any]] = OrderedDict()
        
        # Lock para opera√ß√µes thread-safe
        self.lock = threading.Lock()
        
        # Estat√≠sticas
        self.hits = 0
        self.misses = 0
        self.total_acessos = 0
        
        # ID da sess√£o atual
        self.sessao_id = self._gerar_sessao_id()
        
        print(f"‚úÖ Sistema de mem√≥ria contextual iniciado (capacidade: {capacidade_maxima}, expira√ß√£o: {tempo_expiracao_minutos}min)")
    
    def _gerar_sessao_id(self) -> str:
        """Gera ID √∫nico para a sess√£o"""
        return f"sessao_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    def adicionar_interacao(self, pergunta: str, resposta: str, metadados: Optional[Dict] = None):
        """
        Adiciona uma intera√ß√£o pergunta-resposta √† mem√≥ria
        
        Args:
            pergunta: Pergunta do usu√°rio
            resposta: Resposta do sistema
            metadados: Informa√ß√µes adicionais (reuni√µes encontradas, contexto, etc)
        """
        with self.lock:
            # Criar chave √∫nica para a intera√ß√£o
            timestamp = datetime.now()
            chave = f"{self.sessao_id}_{timestamp.strftime('%H%M%S%f')}"
            
            # Preparar entrada
            entrada = {
                'timestamp': timestamp,
                'pergunta': pergunta,
                'resposta': resposta,
                'metadados': metadados or {},
                'acessos': 1,
                'ultimo_acesso': timestamp
            }
            
            # Se atingiu capacidade m√°xima, remover entrada mais antiga
            if len(self.memoria) >= self.capacidade_maxima:
                # Remove o item menos recentemente usado (primeiro da OrderedDict)
                item_removido = self.memoria.popitem(last=False)
                print(f"üóëÔ∏è  Mem√≥ria LRU: removida entrada antiga {item_removido[0]}")
            
            # Adicionar nova entrada
            self.memoria[chave] = entrada
            
            # Limpar entradas expiradas
            self._limpar_expiradas()
            
            print(f"üíæ Mem√≥ria: adicionada intera√ß√£o (total: {len(self.memoria)})")
    
    def obter_contexto_recente(self, limite: int = 5) -> List[Dict[str, Any]]:
        """
        Obt√©m as intera√ß√µes mais recentes
        
        Args:
            limite: N√∫mero m√°ximo de intera√ß√µes a retornar
            
        Returns:
            Lista com as intera√ß√µes mais recentes
        """
        with self.lock:
            self.total_acessos += 1
            
            # Pegar as √∫ltimas N entradas
            entradas_recentes = list(self.memoria.values())[-limite:]
            
            # Atualizar estat√≠sticas
            if entradas_recentes:
                self.hits += 1
            else:
                self.misses += 1
            
            # Atualizar √∫ltimo acesso
            for entrada in entradas_recentes:
                entrada['ultimo_acesso'] = datetime.now()
                entrada['acessos'] += 1
            
            return entradas_recentes
    
    def buscar_por_tema(self, tema: str, limite: int = 10) -> List[Dict[str, Any]]:
        """
        Busca intera√ß√µes relacionadas a um tema espec√≠fico
        
        Args:
            tema: Tema ou palavra-chave para buscar
            limite: N√∫mero m√°ximo de resultados
            
        Returns:
            Lista de intera√ß√µes relevantes
        """
        with self.lock:
            self.total_acessos += 1
            tema_lower = tema.lower()
            
            resultados = []
            for chave, entrada in self.memoria.items():
                # Buscar tema na pergunta, resposta ou metadados
                if (tema_lower in entrada['pergunta'].lower() or 
                    tema_lower in entrada['resposta'].lower() or
                    any(tema_lower in str(v).lower() for v in entrada['metadados'].values())):
                    
                    resultados.append(entrada)
                    # Mover para o final (mais recente) na OrderedDict
                    self.memoria.move_to_end(chave)
                    # Atualizar acesso
                    entrada['ultimo_acesso'] = datetime.now()
                    entrada['acessos'] += 1
                
                if len(resultados) >= limite:
                    break
            
            # Atualizar estat√≠sticas
            if resultados:
                self.hits += 1
            else:
                self.misses += 1
            
            return resultados
    
    def obter_resumo_sessao(self) -> Dict[str, Any]:
        """
        Obt√©m resumo da sess√£o atual
        
        Returns:
            Dicion√°rio com estat√≠sticas e resumo
        """
        with self.lock:
            if not self.memoria:
                return {
                    'sessao_id': self.sessao_id,
                    'total_interacoes': 0,
                    'duracao': '0 minutos',
                    'temas_principais': [],
                    'estatisticas': self.obter_estatisticas()
                }
            
            # Calcular dura√ß√£o
            timestamps = [entrada['timestamp'] for entrada in self.memoria.values()]
            inicio = min(timestamps)
            fim = max(timestamps)
            duracao = fim - inicio
            
            # Extrair temas dos metadados
            todos_temas = []
            for entrada in self.memoria.values():
                if 'temas' in entrada['metadados']:
                    todos_temas.extend(entrada['metadados']['temas'])
            
            # Contar frequ√™ncia de temas
            from collections import Counter
            temas_freq = Counter(todos_temas)
            temas_principais = [tema for tema, _ in temas_freq.most_common(5)]
            
            return {
                'sessao_id': self.sessao_id,
                'total_interacoes': len(self.memoria),
                'duracao': f"{duracao.total_seconds() / 60:.1f} minutos",
                'temas_principais': temas_principais,
                'inicio_sessao': inicio.strftime('%H:%M:%S'),
                'ultima_interacao': fim.strftime('%H:%M:%S'),
                'estatisticas': self.obter_estatisticas()
            }
    
    def _limpar_expiradas(self):
        """Remove entradas que expiraram"""
        agora = datetime.now()
        chaves_remover = []
        
        for chave, entrada in self.memoria.items():
            if agora - entrada['ultimo_acesso'] > self.tempo_expiracao:
                chaves_remover.append(chave)
        
        for chave in chaves_remover:
            del self.memoria[chave]
            
        if chaves_remover:
            print(f"üßπ Mem√≥ria: removidas {len(chaves_remover)} entradas expiradas")
    
    def obter_estatisticas(self) -> Dict[str, Any]:
        """Obt√©m estat√≠sticas de uso da mem√≥ria"""
        taxa_acerto = (self.hits / self.total_acessos * 100) if self.total_acessos > 0 else 0
        
        return {
            'total_entradas': len(self.memoria),
            'capacidade_usada': f"{len(self.memoria) / self.capacidade_maxima * 100:.1f}%",
            'total_acessos': self.total_acessos,
            'hits': self.hits,
            'misses': self.misses,
            'taxa_acerto': f"{taxa_acerto:.1f}%"
        }
    
    def limpar_memoria(self):
        """Limpa toda a mem√≥ria"""
        with self.lock:
            tamanho_anterior = len(self.memoria)
            self.memoria.clear()
            self.hits = 0
            self.misses = 0
            self.total_acessos = 0
            print(f"üóëÔ∏è  Mem√≥ria limpa: {tamanho_anterior} entradas removidas")
    
    def exportar_sessao(self) -> Dict[str, Any]:
        """
        Exporta dados da sess√£o para poss√≠vel persist√™ncia
        
        Returns:
            Dicion√°rio com todos os dados da sess√£o
        """
        with self.lock:
            return {
                'sessao_id': self.sessao_id,
                'timestamp_export': datetime.now().isoformat(),
                'resumo': self.obter_resumo_sessao(),
                'interacoes': [
                    {
                        'timestamp': entrada['timestamp'].isoformat(),
                        'pergunta': entrada['pergunta'],
                        'resposta': entrada['resposta'],
                        'metadados': entrada['metadados'],
                        'acessos': entrada['acessos']
                    }
                    for entrada in self.memoria.values()
                ]
            }
    
    def formatar_contexto_para_agente(self, limite: int = 3) -> str:
        """
        Formata o contexto recente para ser usado pelo agente
        
        Args:
            limite: N√∫mero de intera√ß√µes a incluir
            
        Returns:
            String formatada com o contexto
        """
        interacoes = self.obter_contexto_recente(limite)
        
        if not interacoes:
            return ""
        
        contexto_parts = ["### Contexto da Conversa Anterior ###\n"]
        
        for i, interacao in enumerate(interacoes, 1):
            contexto_parts.append(f"**Intera√ß√£o {i}:**")
            contexto_parts.append(f"- Pergunta: {interacao['pergunta']}")
            contexto_parts.append(f"- Resposta: {interacao['resposta'][:200]}...")
            
            if interacao['metadados'].get('reunioes_encontradas'):
                contexto_parts.append(f"- Reuni√µes mencionadas: {', '.join(interacao['metadados']['reunioes_encontradas'])}")
            
            contexto_parts.append("")
        
        return "\n".join(contexto_parts)


class GerenciadorMemoria:
    """
    Gerenciador de mem√≥ria que integra com o sistema AURALIS
    """
    
    def __init__(self):
        self.memoria = MemoriaContextualLRU()
        self.ativo = True
        
    def processar_interacao(self, pergunta: str, resposta: str, 
                          reunioes_encontradas: Optional[List[str]] = None,
                          confidence_score: Optional[float] = None):
        """
        Processa e armazena uma intera√ß√£o completa
        """
        metadados = {}
        
        if reunioes_encontradas:
            metadados['reunioes_encontradas'] = reunioes_encontradas
        
        if confidence_score is not None:
            metadados['confidence_score'] = confidence_score
        
        # Extrair poss√≠veis temas da pergunta
        palavras_chave = [p for p in pergunta.lower().split() 
                         if len(p) > 4 and p not in ['sobre', 'quais', 'quando', 'onde', 'como']]
        if palavras_chave:
            metadados['temas'] = palavras_chave[:3]
        
        self.memoria.adicionar_interacao(pergunta, resposta, metadados)
    
    def obter_contexto(self) -> str:
        """Obt√©m contexto formatado para o agente"""
        return self.memoria.formatar_contexto_para_agente()
    
    def fechar_sessao(self):
        """Finaliza a sess√£o e limpa a mem√≥ria"""
        if self.ativo:
            resumo = self.memoria.obter_resumo_sessao()
            print("\nüìä Resumo da Sess√£o:")
            print(f"   - ID: {resumo['sessao_id']}")
            print(f"   - Dura√ß√£o: {resumo['duracao']}")
            print(f"   - Total de intera√ß√µes: {resumo['total_interacoes']}")
            print(f"   - Taxa de acerto do cache: {resumo['estatisticas']['taxa_acerto']}")
            
            self.memoria.limpar_memoria()
            self.ativo = False


# Inst√¢ncia global do gerenciador (ser√° criada quando necess√°rio)
_gerenciador_memoria: Optional[GerenciadorMemoria] = None

def obter_gerenciador_memoria() -> GerenciadorMemoria:
    """Obt√©m ou cria a inst√¢ncia global do gerenciador de mem√≥ria"""
    global _gerenciador_memoria
    if _gerenciador_memoria is None:
        _gerenciador_memoria = GerenciadorMemoria()
    return _gerenciador_memoria


# Testes da mem√≥ria
if __name__ == "__main__":
    print("üß™ Testando sistema de mem√≥ria contextual\n")
    
    # Criar gerenciador
    gerenciador = GerenciadorMemoria()
    
    # Simular intera√ß√µes
    interacoes = [
        ("Qual foi a √∫ltima reuni√£o sobre vendas?", 
         "A √∫ltima reuni√£o sobre vendas foi em 04/02/2024...", 
         ["reuniao_04_02_2024.txt"]),
        
        ("Quem participou dessa reuni√£o?", 
         "Participaram Jo√£o Silva, Maria Santos e Pedro Costa...", 
         ["reuniao_04_02_2024.txt"]),
        
        ("Quais foram as decis√µes sobre o novo produto?", 
         "As principais decis√µes foram: lan√ßamento em mar√ßo, pre√ßo inicial de R$ 99...", 
         ["reuniao_04_02_2024.txt"]),
        
        ("Existe alguma reuni√£o sobre marketing?", 
         "Encontrei 2 reuni√µes sobre marketing...", 
         ["reuniao_15_01_2024.txt", "reuniao_20_01_2024.txt"])
    ]
    
    # Processar intera√ß√µes
    for pergunta, resposta, reunioes in interacoes:
        print(f"\nüîÑ Processando: {pergunta[:50]}...")
        gerenciador.processar_interacao(pergunta, resposta, reunioes, confidence_score=0.95)
        time.sleep(0.1)
    
    # Mostrar contexto
    print("\nüìã Contexto atual:")
    print(gerenciador.obter_contexto())
    
    # Buscar por tema
    print("\nüîç Buscando intera√ß√µes sobre 'vendas':")
    resultados = gerenciador.memoria.buscar_por_tema("vendas", limite=3)
    for r in resultados:
        print(f"   - {r['pergunta'][:60]}...")
    
    # Estat√≠sticas
    print("\nüìä Estat√≠sticas:")
    stats = gerenciador.memoria.obter_estatisticas()
    for k, v in stats.items():
        print(f"   - {k}: {v}")
    
    # Fechar sess√£o
    print("\n")
    gerenciador.fechar_sessao()